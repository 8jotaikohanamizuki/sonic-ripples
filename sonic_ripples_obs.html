<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>TAKESHIBA: Voice Waves</title>
<style>
html, body {
    margin: 0;
    padding: 0;
    background: transparent;
    overflow: hidden;
}
canvas {
    display: block;
    background: transparent;
}
#status {
    position: absolute;
    bottom: 10px;
    left: 10px;
    color: rgba(0, 240, 255, 0.4);
    font-family: monospace;
    font-size: 0.7rem;
    z-index: 100;
}
</style>
</head>
<body>

<canvas id="canvas"></canvas>
<div id="status">接続中...</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const statusEl = document.getElementById('status');

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

let ripples = [];

// ── obs-websocket 設定 ──────────────────────────────────────
const OBS_HOST = 'localhost';
const OBS_PORT = 4455;

// ── WebSocket接続 ────────────────────────────────────────────
let ws;
let reconnectTimer;

function connect() {
    ws = new WebSocket(`ws://${OBS_HOST}:${OBS_PORT}`);

    ws.onopen = () => {
        statusEl.textContent = 'OBS接続済み ✓';
        setTimeout(() => statusEl.style.display = 'none', 3000);
    };

    ws.onmessage = (event) => {
        const msg = JSON.parse(event.data);

        // obs-websocket v5 のハンドシェイク
        if (msg.op === 0) {
            // Hello → Identify
            ws.send(JSON.stringify({
                op: 1,
                d: { rpcVersion: 1 }
            }));
        }

        if (msg.op === 2) {
            // Identified → 音声レベルのサブスクライブ
            ws.send(JSON.stringify({
                op: 6,
                d: {
                    requestType: 'SetInputVolume',
                    requestId: 'init'
                }
            }));

            // InputVolumeMeters イベントを購読
            ws.send(JSON.stringify({
                op: 6,
                d: {
                    requestType: 'GetInputList',
                    requestId: 'getInputs'
                }
            }));

            // イベントサブスクリプション（音声メーター）
            // EventSubscription: InputVolumeMeters = 1 << 17 = 131072
            ws.send(JSON.stringify({
                op: 1,
                d: {
                    rpcVersion: 1,
                    eventSubscriptions: 131072
                }
            }));
        }

        // 音声メーターイベント
        if (msg.op === 5 && msg.d.eventType === 'InputVolumeMeters') {
            const inputs = msg.d.eventData.inputs;
            inputs.forEach(input => {
                if (input.inputLevelsMul && input.inputLevelsMul.length > 0) {
                    // 音量レベル（0.0〜1.0）を取得
                    const levels = input.inputLevelsMul[0];
                    const peak = levels[1] || levels[0] || 0; // peak値
                    const volume = peak * 255;
                    maybeAddRipple(volume);
                }
            });
        }
    };

    ws.onclose = () => {
        statusEl.style.display = 'block';
        statusEl.textContent = '再接続中...';
        reconnectTimer = setTimeout(connect, 3000);
    };

    ws.onerror = () => {
        statusEl.style.display = 'block';
        statusEl.textContent = 'OBS接続エラー';
    };
}

// ── 波紋生成 ─────────────────────────────────────────────────
function maybeAddRipple(volume) {
    if (volume > 45) {
        let power = (volume - 45) / (255 - 45);
        ripples.push({
            x: canvas.width / 2,
            y: canvas.height / 2,
            r: 5,
            opacity: 1,
            lineWidth: 2 + (power * 12),
            speed: 2 + (power * 12),
            color: `120, ${Math.floor(180 + power * 75)}, 255`
        });
    }
}

// ── 描画ループ ────────────────────────────────────────────────
function draw() {
    requestAnimationFrame(draw);
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    for (let i = ripples.length - 1; i >= 0; i--) {
        const ripple = ripples[i];
        ctx.beginPath();
        ctx.arc(ripple.x, ripple.y, ripple.r, 0, Math.PI * 2);
        ctx.strokeStyle = `rgba(${ripple.color}, ${ripple.opacity})`;
        ctx.lineWidth = ripple.lineWidth;
        ctx.stroke();

        ripple.r += ripple.speed;
        ripple.opacity -= 0.02;

        if (ripple.opacity <= 0) ripples.splice(i, 1);
    }
}

window.addEventListener('resize', () => {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
});

connect();
draw();
</script>

</body>
</html>
